(in-package :crawler2)

(defmethod filter-connectable ((stage labyrinth) neighborhood)
  (with-accessors ((o origin) (n n) (s s) (e e) (w w)) neighborhood
    (let ((ns (mapcar #'region-id (list n s)))
          (ew (mapcar #'region-id (list e w))))
      (and (not (region-id o))
           (or (and (not (apply #'eql ns))
                    (not (some #'null ns)))
               (and (not (apply #'eql ew))
                    (not (some #'null ew))))))))

(defmethod connect ((stage labyrinth) neighborhood)
  (let ((cell (origin neighborhood)))
    (with-slots (adjacent-regions) cell
      (setf adjacent-regions (remove nil (nmap neighborhood #'region-id)))
      (dolist (region-id adjacent-regions)
        (push cell (connectors (get-region stage region-id)))))))

(defmethod remove-extra-connectors ((stage labyrinth) source target)
  (let ((region1 (get-region stage source))
        (region2 (get-region stage target)))
    (dolist (cell (connectors region1))
      (let ((adjacent (adjacent-regions cell)))
        (when (and (member source adjacent)
                   (member target adjacent))
          (deletef (connectors region1) cell)
          (deletef (connectors region2) cell))))))

(defmethod move-connectors ((stage labyrinth) source target)
  (let ((region1 (get-region stage source))
        (region2 (get-region stage target)))
    (dolist (cell (connectors region1))
      (setf (adjacent-regions cell)
            (substitute target source (adjacent-regions cell)))
      (push cell (connectors region2)))))
